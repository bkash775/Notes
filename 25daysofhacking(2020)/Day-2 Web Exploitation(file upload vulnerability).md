### ﻿_GET Parameters and URLs_

`https://www.thebestfestivalcompany.xyz/index.php?snack=mincePie`

There are 7 different parts which make up this URL. Let's look at each of them in turn:  
![](https://i.imgur.com/wTKxQot.png)  
  

1. First up we have the protocol (`https://`). This specifies whether the request should be made using HTTP, or HTTPS. In our example, we are using HTTPS.
2. Next we have the _subdomain_ (`www`). This is traditionally "www" (**W**orld **W**ide **W**eb) to signify that the target is a website; however, this is not essential. Indeed, subdomains can be basically anything you want; for example, a lot of websites use things like "`assets`", or "`api`" to indicate different subdomains with different uses. (e.g. `https://api.thebestfestivalcompany.xyz`)
3. The next part of the URL is the _domain_ (`thebestfestivalcompany`). Domains need to be registered and are used as links between a memorable word or phrase, and an IP address. In other words, they're used to give a _name_ to the server running a website.
4. Next up we have the TLD (**T**op **L**evel **D**omain) -- `.xyz`, for our example. Top-level domains are used by DNS to determine where to look if they want to find your domain. Previously top-level domains had specific uses (and many still do!), but this is not always the case these days. For example, `.co.uk`  indicates a company based in the UK, `.com` indicates a company based in the US.
5. We then have the _resource_ that we're selecting -- in this case that is the homepage of the website: `index.php`. As a side note, all homepages _must_ be called "index" in order to be correctly served by the web server without having to be specified fully, unless this parameter has been changed from the default in the webserver configuration. This is how you can go to `https://tryhackme.com` without having to specify that you want to receive the home page -- the index page is served automatically because you didn't specify!
6. The final two aspects of the URL are the most important for our current topic: they both relate to GET parameters. First up we have `?snack=`. Here `?` is used to specify that a GET parameter is forthcoming. We then have the parameter name: `snack`. This is used to identify the parameter to the server. We then have an equals sign (`=`), indicating that the value will come next.
7. Finally, we have the value of the GET parameter: `mincePie`, because who doesn't like mince pies, right?

It's important to note exactly which part of the URL is the GET parameter. Specifically, we are talking about `?snack=mincePie`. If there was more than one parameter, we would separate them with an ampersand (`&`). For example: `?snack=mincePie&drink=hotChocolate`. In this way we can send multiple values to the server, distinguished by keys (i.e. "mincePie" is identified by the key: "snack").

### _File Uploads_
- _File Extension Filtering:_ As the name suggests extension filtering checks the file extension of uploaded files. This is often done by specifying a list of allowed extensions, then checking the uploaded file against the list. If the extension is not in the allowlist, the upload is rejected.
- So, what's the bypass? Well, the answer is that it depends entirely on how the filter is implemented. Many extension filters split a filename at the dot (`.`) and check what comes after it against the list. This makes it very easy to bypass by uploading a double-barrelled extension (e.g. `.jpg.php`). The filter splits at the dot(s), then checks what it thinks is the extension against the list. If jpg is an allowed extension then the upload will succeed and our malicious PHP script will be uploaded to the server.

### _Reverse Shells_
PHP reverse shells can be very easily activated when stored in an accessible location: simply navigate to the file in your browser to execute the script (and send the reverse shell):

![](https://i.imgur.com/e0lOjZ5.png)

### _Reverse Shell Listeners_

![](https://i.imgur.com/GjjcCrr.png)  
We've spoken at length about reverse shell listeners, but what are they? In short, a reverse shell listener is used to open a network socket to receive a raw connection -- like the one created by a reverse shell being executed! The simplest form of listener is created by using a program called _netcat_, which is installed on both Kali and the AttackBox by default. We can create a listener for an uploaded reverse shell by using this command: `sudo nc -lvnp 443`. This essentially creates a listener on port 443. In a real-world environment, you would want to use a common port such as 443 that is not filtered by firewalls in most scenarios, increasing the chances our reverse shell connects back.. Once _netcat_ has been setup, our reverse shell will be able to connect back to this when activated.

****exploiting a file upload vulnerability in a PHP web application:

1. Find a file upload point.
2. Try uploading some innocent files -- what does it accept? (Images, text files, PDFs, etc)
3. Find the directory containing your uploads.
4. Try to bypass any filters and upload a reverse shell.
5. Start a netcat listener to receive the shell
6. Navigate to the shell in your browser and receive a connection!


What string of text needs adding to the URL to get access to the upload page?
?id=ODIzODI5MTNiYmYw

What type of file is accepted by the site?
image
uploaded revshell.jpg.php 

Bypass the filter and upload a reverse shell.

In which directory are the uploaded files stored?
/uploads

Activated the reverse shell and catch it in a netcat listener!
What is the flag in `/var/www/flag.txt`?
THM{MGU3Y2UyMGUwNjExYTY4NTAxOWJhMzhh}

